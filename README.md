# Dépôt d'Algorithmes pour la Préparation aux Coding Interviews

Ce dépôt regroupe divers algorithmes organisés par structure de données, implémentés en Python sous forme de notebooks Jupyter, que j’ai développés dans le cadre de ma formation en Master 1 (Développement Logiciel et IoT). Le but de ce projet est de renforcer mes compétences en résolution de problèmes d'algorithmes, en particulier pour des exercices souvent rencontrés dans des **coding interviews** et sur des plateformes comme **LeetCode**. Chaque notebook présente une solution à un problème spécifique, et peut servir de référence pour la compréhension de ces algorithmes.

## Objectifs du Dépôt

- **Entraînement pratique** : Résoudre des problèmes d'algorithmes pour améliorer mes compétences de programmation.
- **Révision des concepts fondamentaux** : Appliquer et maîtriser différentes structures de données (tableaux, listes chaînées, piles, files d'attente, etc.).
- **Préparation aux entretiens techniques** : Ce dépôt couvre des problèmes fréquemment posés lors des entretiens techniques pour les rôles de développeurs, notamment dans des domaines nécessitant une compréhension approfondie des algorithmes et des structures de données.

## Contenu du Dépôt

Le dépôt est organisé en répertoires, chacun représentant une structure de données spécifique. Chaque notebook se concentre sur un problème particulier, avec une explication de l'approche et du code.

### Arrays (Tableaux)

1. **Buy_Sell.ipynb** : Algorithme pour maximiser les profits d'achat et de vente d'actions.
2. **Maximum_Subarray.ipynb** : Résolution du problème de sous-tableau de somme maximale.
3. **Product_Array_Except_Self.ipynb** : Calcul du produit de tous les éléments sauf le soi-même sans division.
4. **Subarray_Sum.ipynb** : Calcul de la somme de sous-tableaux pour une somme cible donnée.
5. **Two_Sum.ipynb** : Recherche de deux éléments dans un tableau qui forment une somme cible.

### Linked Lists (Listes Chaînées)

1. **Add_Two_Numbers.ipynb** : Somme de deux nombres représentés par des listes chaînées.
2. **Linked_List_Cycle.ipynb** : Détection de cycles dans une liste chaînée.
3. **LRU_Cache.ipynb** : Implémentation d'un cache LRU (Least Recently Used).
4. **Merge_Two_Sorted_Lists.ipynb** : Fusion de deux listes triées.
5. **Reverse_List.ipynb** : Inversion d'une liste chaînée.

### Queues (Files d'Attente)

1. **Implement_Queue.ipynb** : Implémentation de base d'une file d'attente.
2. **Number_Islands.ipynb** : Calcul du nombre d'îles dans une grille (utilisation des files d'attente pour la recherche).
3. **Sliding_Window_Maximum.ipynb** : Calcul du maximum dans une fenêtre coulissante sur un tableau.

### Stacks (Piles)

1. **Daily_Temperatures.ipynb** : Calcul des jours d'attente pour des températures plus élevées.
2. **Min_Stack.ipynb** : Pile qui maintient également le minimum actuel.
3. **Polish_Notation.ipynb** : Évaluation d'expressions en notation polonaise inversée.
4. **Rectangle_Histogram.ipynb** : Calcul de l'aire maximale d'un rectangle dans un histogramme.
5. **Valid_Parentheses.ipynb** : Validation des parenthèses dans une expression.

## Utilisation

Chaque notebook peut être exploré individuellement pour comprendre l'approche et l'implémentation du problème en question. Ces notebooks peuvent être utilisés pour une préparation autonome ou comme référence rapide pour réviser un type de problème particulier.

## Pré-requis

Les notebooks nécessitent un environnement Jupyter et Python (version 3.6 ou plus récente). Pour installer Jupyter et lancer les notebooks, vous pouvez exécuter les commandes suivantes :

```bash
pip install notebook
jupyter notebook
```
